---
layout: post
title: 空指针，通用指针，野指针
---

首先，空指针必定是一个指针常量。即给一个指针赋值为0，如：

	int *p=0;//p便是一个空指针。由系统保证不指向任何有意义的地址，其实空指针是一种编程概念，表示一个指针在概念上不指向任何内存（注意是概念上）。
	//那么，空指针到底向了内存的什么地方？这个因编译器而异，一般来说，编译器都不会将空指针真的指向地址为0x0000，而是有一块特殊的地址用来表示空指针，具体指向什么地///址，这些细节不用关心。
	int *p=NULL;//这也是空指针，NULL在C++中宏定义为0.
	int a = 1;//声明了一个普通的int类型数据a
	void *p1=&a;//定义了一个通用指针，通用类型指针在声明时并不指定该指针的明确指向类型，也就是说它可以指向任何类型的变量。
	int *p2=&a;
	int *p3;                      //野指针
	
	cout << *p << endl;          //尝试读取空指针的值，引起程序崩溃，因为编译器从一开始就保证了空指针不会指向任何一块逻辑意义上的地址，所以尝试去读取是无意义的
	cout << p << endl;           //输出为0，但是并不代表真的指向为0的地址
	cout << (int*)p1 << endl;    //输出为0x22ffcf诸如此类的一个地址，在对p1进行操作的时候必须先将其强制转换为某一特定指针才行
	cout<<*(int*)p1<<endl;       //输出为1
	cout << *p2 << endl;             //输出为1
	cout<<p3<<endl;                  //p3是一个野指针，跟本无法预料其指向
	cout<<*p3<<endl;                 //无法预料野指针所指向的值
	
野指针的危害非常大，产生的主要原因如下：
> 指针变量没有初始化，任何指针没有初始化时不会自动置为NULL，其缺省值是随机的，它会乱指一气。
> 指针被free和delete后，没有置为NULL，free和delete只会将内存释放掉，但是指针本身仍然存在。并且指针仍然指向该地址，只不过内存已经变成了垃圾
> 指针操作超出了变量的生命周期

