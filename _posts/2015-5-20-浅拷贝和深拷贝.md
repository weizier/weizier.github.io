---
layout: post
title: 浅拷贝和深拷贝
---


这篇博文主要来自今天下午在百分点面试的一道题，我当时做的是python试卷，里面有一道题是关于copy包的，我之前从未用过这个包，但是一看名字呢还是知道要考察的内容是浅拷贝以及深拷贝，回来之后查了相关内容，发现我原先对浅拷贝以及深拷贝的理解还是不那么充分的。下面就主要针对这部分来做一个小小的总结。

###引用和赋值
和其他语言不一样，传递参数的时候，python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。实际上，这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值'来传递对象。

python一般内部赋值变量的话，都是传个引用变量，和C语言的传地址的概念差不多。可以用id()来查询内存地址

如果执行a=b的话，a和b的地址是相同的，即id(a)=id(b)；如果只是想拷贝，那么就得用 a=b[:]，执行该语句后，id(a)!=id(b)

其实C++也好，Java也好，甚至是Python也好，其背后的本质都是传递了一个值。只是说C++中的引用传递的就是当前对象的地址，在函数内部对该地址进行处理的时候，当然就直接在原始对象上进行开刀了，这是所谓引用，引用基本可以认为是const指针。C++中当用指针作为参数时，其背后也是传递了一个地址。因此，Java中的引用作为参数，实际上更像C++中的指针作为参数，如果对Java中的内存管理机制非常熟悉的话，那么Java中的引用传递机制不会很复杂，其本质是一个指针，只不过它存储在栈上，其内容便是所指向对象在堆空间的地址，当我们用引用作为参数的时候，便可以理解成将一个引用中的地址传递给函数形参，所以背后的机理和C++中的指针是完全一样的。而Python中叶和此类似。

	>>> seq = [1, 2, 3] 
	>>> seq_2 = seq 
	>>> seq_2.append(4) 
	>>> print seq, seq_2 [1, 2, 3, 4] [1, 2, 3, 4] 
	>>> seq.append(5) 
	>>> print seq, seq_2 [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]
	
	>>> a = 1 
	>>> b = a 
	>>> b = 2 
	>>> print a, b 1 2 
	>>> c = (1, 2) 
	>>> d = c 
	>>> d = (1, 2, 3) 
	>>> print c, d (1, 2) (1, 2, 3)
	

	
###浅拷贝和深拷贝
在Python中，要实现浅拷贝和深拷贝，只能利用import copy这个包
copy.copy 浅拷贝 只拷贝父对象，不会拷贝对象的内部的子对象。也就是说拷贝了父对象的最上面一层，会将最表面的那一层复制一个副本出来，但是对其内子对象则仍然是原来的那些对象，所以如果对其内子对象进行处理的话，那就相当于直接在原始数据上的内部子对象上面操作是一样的。但是父对象由于拷贝了一个副本，那么最表面一层的父对象不会受到影响。如果用deepcopy的话，则完全不受到影响了，因为deepcopy会对其内所有子对象即便有好几层都一样进行复制，也就是全都做了一个副本。所有原始数据和新的深拷贝出来的数据二者之间完全不再有任何关联了。

	>>> m = [1, ['a'], 2] 
	>>> m_1 = m 
	>>> m_2 = copy.copy(m) 
	>>> m_3 = copy.deepcopy(m) 
	>>> m[1].append('b') 
	>>> print m, m_1, m_2, m_3 [1, ['a', 'b'], 2] [1, ['a', 'b'], 2] [1, ['a', 'b'], 2] [1, ['a'], 2] >>> m_2[1].append('c') 
	>>> print m, m_1, m_2, m_3 [1, ['a', 'b', 'c'], 2] [1, ['a', 'b', 'c'], 2] [1, ['a', 'b', 'c'], 2] [1, ['a'], 2] 
	>>> m_3[1].append('d') 
	>>> print m, m_1, m_2, m_3 [1, ['a', 'b', 'c'], 2] [1, ['a', 'b', 'c'], 2] [1, ['a', 'b', 'c'], 2] [1, ['a', 'd'], 2]	
	
	import copy
	a = [1, 2, 3, 4, ['a', 'b']]  #原始对象
	b = a  #赋值，传对象的引用
	c = copy.copy(a)  #对象拷贝，浅拷贝
	d = copy.deepcopy(a)  #对象拷贝，深拷贝
	a.append(5)  #修改对象a
	a[4].append('c')  #修改对象a中的['a', 'b']数组对象
	print 'a = ', a
	print 'b = ', b
	print 'c = ', c
	print 'd = ', d
输出如下：
	a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
	b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
	c =  [1, 2, 3, 4, ['a', 'b', 'c']]
	d =  [1, 2, 3, 4, ['a', 'b']]